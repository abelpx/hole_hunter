package repository

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/holehunter/holehunter/internal/models"
)

type VulnerabilityRepository struct {
	db *sql.DB
}

func NewVulnerabilityRepository(db *sql.DB) *VulnerabilityRepository {
	return &VulnerabilityRepository{db: db}
}

func (r *VulnerabilityRepository) GetAll() ([]models.Vulnerability, error) {
	rows, err := r.db.Query(`
		SELECT id, task_id, template_id, severity, name, description, url,
		       matched_at, false_positive, notes, cve, cvss, created_at
		FROM vulnerabilities ORDER BY created_at DESC
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []models.Vulnerability
	for rows.Next() {
		var v models.Vulnerability
		if err := rows.Scan(
			&v.ID, &v.TaskID, &v.TemplateID, &v.Severity, &v.Name, &v.Description,
			&v.URL, &v.MatchedAt, &v.FalsePositive, &v.Notes, &v.CVE, &v.CVSS, &v.CreatedAt,
		); err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

func (r *VulnerabilityRepository) GetByTaskID(taskID int) ([]models.Vulnerability, error) {
	rows, err := r.db.Query(`
		SELECT id, task_id, template_id, severity, name, description, url,
		       matched_at, false_positive, notes, cve, cvss, created_at
		FROM vulnerabilities WHERE task_id = ? ORDER BY created_at DESC
	`, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []models.Vulnerability
	for rows.Next() {
		var v models.Vulnerability
		if err := rows.Scan(
			&v.ID, &v.TaskID, &v.TemplateID, &v.Severity, &v.Name, &v.Description,
			&v.URL, &v.MatchedAt, &v.FalsePositive, &v.Notes, &v.CVE, &v.CVSS, &v.CreatedAt,
		); err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

func (r *VulnerabilityRepository) GetByID(id int) (*models.Vulnerability, error) {
	var v models.Vulnerability
	err := r.db.QueryRow(`
		SELECT id, task_id, template_id, severity, name, description, url,
		       matched_at, false_positive, notes, cve, cvss, created_at
		FROM vulnerabilities WHERE id = ?
	`, id).Scan(
		&v.ID, &v.TaskID, &v.TemplateID, &v.Severity, &v.Name, &v.Description,
		&v.URL, &v.MatchedAt, &v.FalsePositive, &v.Notes, &v.CVE, &v.CVSS, &v.CreatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("vulnerability not found: %d", id)
	}
	if err != nil {
		return nil, err
	}

	return &v, nil
}

func (r *VulnerabilityRepository) Create(taskID int, templateID, severity, name, description, url, matchedAt, cve string, cvss float64) (*models.Vulnerability, error) {
	now := time.Now().Format("2006-01-02 15:04:05")

	result, err := r.db.Exec(`
		INSERT INTO vulnerabilities (task_id, template_id, severity, name, description, url, matched_at, cve, cvss, created_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`, taskID, templateID, severity, name, description, url, matchedAt, cve, cvss, now)
	if err != nil {
		return nil, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	return &models.Vulnerability{
		ID:            int(id),
		TaskID:        taskID,
		TemplateID:    templateID,
		Severity:      severity,
		Name:          name,
		Description:   description,
		URL:           url,
		MatchedAt:     matchedAt,
		FalsePositive: false,
		CVE:           cve,
		CVSS:          cvss,
		CreatedAt:     now,
	}, nil
}

func (r *VulnerabilityRepository) Update(id int, falsePositive bool, notes string) error {
	_, err := r.db.Exec(`
		UPDATE vulnerabilities
		SET false_positive = ?, notes = ?
		WHERE id = ?
	`, falsePositive, notes, id)
	return err
}

func (r *VulnerabilityRepository) Delete(id int) error {
	_, err := r.db.Exec("DELETE FROM vulnerabilities WHERE id = ?", id)
	return err
}

func (r *VulnerabilityRepository) DeleteByTaskID(taskID int) error {
	_, err := r.db.Exec("DELETE FROM vulnerabilities WHERE task_id = ?", taskID)
	return err
}
